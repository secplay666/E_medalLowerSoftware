<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸²å£è°ƒè¯•å·¥å…· - å®Œæ•´ç‰ˆ V3</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 10px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1600px;
            margin: 0 auto;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .panel {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .section-title {
            background: linear-gradient(90deg, #667eea, #764ba2);
            color: white;
            padding: 10px 15px;
            border-radius: 4px;
            margin: -15px -15px 15px -15px;
            font-weight: bold;
            font-size: 14px;
        }
        .settings {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            align-items: end;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .control-group label {
            font-weight: 600;
            font-size: 12px;
            color: #333;
        }
        .control-group input,
        .control-group select,
        .control-group textarea {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
            font-family: monospace;
        }
        .control-group input:focus,
        .control-group select:focus,
        .control-group textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }
        button {
            padding: 8px 15px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        textarea {
            width: 100%;
            height: 150px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            resize: vertical;
        }
        .flex-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        .progress-container {
            width: 100%;
            height: 25px;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 11px;
        }
        .info-box {
            background-color: #e3f2fd;
            border-left: 4px solid #2196F3;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 12px;
        }
        .error-box {
            background-color: #ffebee;
            border-left: 4px solid #f44336;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            color: #c62828;
            font-size: 12px;
        }
        .success-box {
            background-color: #e8f5e9;
            border-left: 4px solid #4CAF50;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            color: #2e7d32;
            font-size: 12px;
        }
        .warning-box {
            background-color: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            color: #e65100;
            font-size: 12px;
        }
        canvas {
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }
        .canvas-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 15px 0;
        }
        .image-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .checkbox-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .checkbox-item input[type="checkbox"] {
            cursor: pointer;
        }
        .checkbox-item label {
            cursor: pointer;
            margin: 0;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 5px;
            vertical-align: middle;
        }
        .status-connected {
            background-color: #4CAF50;
        }
        .status-disconnected {
            background-color: #f44336;
        }
        .tabs {
            display: flex;
            gap: 0;
            margin: -15px -15px 15px -15px;
            border-bottom: 1px solid #e0e0e0;
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            background: #f5f5f5;
            color: #333;
            font-weight: 600;
            font-size: 12px;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }
        .tab.active {
            background: white;
            color: #667eea;
            border-bottom-color: #667eea;
        }
        .tab:hover {
            background: #fff;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #eee;
            font-size: 12px;
        }
        .stat-label {
            font-weight: 600;
            color: #666;
        }
        .stat-value {
            color: #667eea;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ”§ ä¸²å£è°ƒè¯•å·¥å…· - å®Œæ•´ç‰ˆ V3 (æ–°åè®®V2)</h1>
            <p>æ”¯æŒå®Œæ•´çš„ä¸²å£é…ç½®ã€å›¾åƒå¤„ç†ã€å®æ—¶ç›‘æ§å’Œæ•°æ®åˆ†æ</p>
        </div>

        <!-- ä¸²å£è¿æ¥è®¾ç½® -->
        <div class="panel">
            <div class="section-title">ğŸ”Œ ä¸²å£è¿æ¥é…ç½®</div>
            <div class="settings">
                <div class="control-group">
                    <label>æ³¢ç‰¹ç‡ (Baud Rate)</label>
                    <select id="baudRate">
                        <option value="300">300</option>
                        <option value="600">600</option>
                        <option value="1200">1200</option>
                        <option value="2400">2400</option>
                        <option value="4800">4800</option>
                        <option value="9600">9600</option>
                        <option value="14400">14400</option>
                        <option value="19200">19200</option>
                        <option value="28800">28800</option>
                        <option value="38400">38400</option>
                        <option value="57600">57600</option>
                        <option value="115200" selected>115200</option>
                        <option value="230400">230400</option>
                        <option value="460800">460800</option>
                        <option value="921600">921600</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>æ•°æ®ä½ (Data Bits)</label>
                    <select id="dataBits">
                        <option value="7">7</option>
                        <option value="8" selected>8</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>æ ¡éªŒä½ (Parity)</label>
                    <select id="parity">
                        <option value="none" selected>æ—  (None)</option>
                        <option value="even">å¶æ ¡éªŒ (Even)</option>
                        <option value="odd">å¥‡æ ¡éªŒ (Odd)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>åœæ­¢ä½ (Stop Bits)</label>
                    <select id="stopBits">
                        <option value="1" selected>1</option>
                        <option value="2">2</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>æµæ§ (Flow Control)</label>
                    <select id="flowControl">
                        <option value="none" selected>æ— </option>
                        <option value="hardware">ç¡¬ä»¶æµæ§</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>RTSæ§åˆ¶ (ç”¨äºå•ç‰‡æœºä¸‹è½½)</label>
                    <div style="display: flex; gap: 15px; align-items: center;">
                        <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                            <input type="radio" id="rtsLow" name="rts" value="0" disabled>
                            <span>0 (ä½ç”µå¹³)</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                            <input type="radio" id="rtsHigh" name="rts" value="1" disabled>
                            <span>1 (é«˜ç”µå¹³)</span>
                        </label>
                    </div>
                </div>
                <div class="control-group">
                    <label>&nbsp;</label>
                    <div class="btn-group">
                        <button id="connectBtn" onclick="connectSerial()">è¿æ¥</button>
                        <button id="disconnectBtn" onclick="disconnectSerial()" disabled>æ–­å¼€</button>
                        <span style="display: inline-flex; align-items: center;">
                            <span class="status-indicator status-disconnected" id="statusLight"></span>
                            <span id="statusText" style="font-size: 12px;">ç¦»çº¿</span>
                        </span>
                    </div>
                </div>
            </div>
        </div>

        <!-- å›¾åƒå¤„ç†å’Œä¼ è¾“ -->
        <div class="panel">
            <div class="section-title">ğŸ–¼ï¸ å›¾åƒå¤„ç†ä¸ä¼ è¾“</div>

            <div class="tabs">
                <button class="tab active" onclick="switchTab(event, 'imageProcessing')">å›¾åƒå¤„ç†</button>
                <button class="tab" onclick="switchTab(event, 'imageTransfer')">å›¾åƒä¼ è¾“</button>
                <button class="tab" onclick="switchTab(event, 'advancedSettings')">é«˜çº§è®¾ç½®</button>
            </div>

            <!-- å›¾åƒå¤„ç†æ ‡ç­¾é¡µ -->
            <div id="imageProcessing" class="tab-content active">
                <div class="settings">
                    <div class="control-group">
                        <label>é€‰æ‹©å›¾åƒ</label>
                        <input type="file" id="imageInput" accept="image/*">
                    </div>
                    <div class="control-group">
                        <label>&nbsp;</label>
                        <button onclick="previewImage()" id="previewBtn" disabled>é¢„è§ˆ</button>
                    </div>
                </div>

                <div class="canvas-container">
                    <div class="image-section">
                        <h4 style="margin: 0 0 10px 0;">åŸå§‹å›¾åƒ</h4>
                        <canvas id="previewCanvas" width="400" height="300"></canvas>
                    </div>
                    <div class="image-section">
                        <h4 style="margin: 0 0 10px 0;">å¤„ç†åå›¾åƒ</h4>
                        <canvas id="processedCanvas" width="400" height="300"></canvas>
                    </div>
                </div>

                <div class="settings">
                    <div class="control-group">
                        <label>å›¾åƒç±»å‹</label>
                        <select id="imageType">
                            <option value="bw">é»‘ç™½ (B&W)</option>
                            <option value="red">çº¢è‰² (Red)</option>
                            <option value="bw_red">é»‘ç™½+çº¢è‰² (B&W+Red)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>ç¼©æ”¾æ¨¡å¼</label>
                        <select id="scaleMode">
                            <option value="fit" selected>é€‚é… (Fit)</option>
                            <option value="fill">å¡«å…… (Fill)</option>
                            <option value="stretch">æ‹‰ä¼¸ (Stretch)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>å›¾åƒå®½åº¦ (px)</label>
                        <input type="number" id="imageWidth" value="400" min="100" max="800">
                    </div>
                    <div class="control-group">
                        <label>å›¾åƒé«˜åº¦ (px)</label>
                        <input type="number" id="imageHeight" value="300" min="100" max="800">
                    </div>
                    <div class="control-group">
                        <label>äºŒå€¼åŒ–é˜ˆå€¼ (0-255)</label>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="range" id="binarizeThresholdSlider" value="128" min="0" max="255" style="flex: 1;">
                            <input type="number" id="binarizeThreshold" value="128" min="0" max="255" style="width: 60px;">
                        </div>
                    </div>
                    <div class="control-group">
                        <label>&nbsp;</label>
                        <button onclick="applyImageProcessing()" id="processBtn" disabled>åº”ç”¨å¤„ç†</button>
                    </div>
                </div>

                <div class="checkbox-group">
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableBinarize" checked>
                        <label for="enableBinarize">å¯ç”¨äºŒå€¼åŒ–</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableLineExtract">
                        <label for="enableLineExtract">çº¿ç¨¿æå–</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableCrop" onchange="showCropSettings()">
                        <label for="enableCrop">å¯ç”¨å‰ªè£</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableInvert">
                        <label for="enableInvert">åè‰²</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableDither">
                        <label for="enableDither">æŠ–åŠ¨</label>
                    </div>
                </div>

                <div id="cropSettings" style="display: none; margin-top: 15px;">
                    <div style="border: 1px dashed #999; padding: 10px; border-radius: 4px;">
                        <div class="settings">
                            <div class="control-group">
                                <label>Xåç§» (px)</label>
                                <input type="number" id="cropX" value="0" min="0">
                            </div>
                            <div class="control-group">
                                <label>Yåç§» (px)</label>
                                <input type="number" id="cropY" value="0" min="0">
                            </div>
                            <div class="control-group">
                                <label>è£å‰ªå®½åº¦ (px)</label>
                                <input type="number" id="cropWidth" value="400" min="100">
                            </div>
                            <div class="control-group">
                                <label>è£å‰ªé«˜åº¦ (px)</label>
                                <input type="number" id="cropHeight" value="300" min="100">
                            </div>
                        </div>
                    </div>
                </div>

                <div id="imageInfo" class="info-box" style="display: none;"></div>
            </div>

            <!-- å›¾åƒä¼ è¾“æ ‡ç­¾é¡µ -->
            <div id="imageTransfer" class="tab-content">
                <div class="settings">
                    <div class="control-group">
                        <label>ç›®æ ‡Slot ID (0-7)</label>
                        <input type="number" id="slotId" min="0" max="7" value="0">
                    </div>
                    <div class="control-group">
                        <label>ä¼ è¾“è¶…æ—¶ (æ¯«ç§’)</label>
                        <input type="number" id="transferTimeout" value="3000" min="1000" max="10000">
                    </div>
                    <div class="control-group">
                        <label>æœ€å¤§é‡è¯•æ¬¡æ•°</label>
                        <input type="number" id="maxRetries" value="5" min="1" max="10">
                    </div>
                    <div class="control-group">
                        <label>&nbsp;</label>
                        <div class="btn-group">
                            <button id="sendBtn" onclick="sendImage()" disabled>å¼€å§‹ä¼ è¾“</button>
                            <button id="stopBtn" onclick="stopTransfer()" disabled>åœæ­¢</button>
                            <button id="resetBtn" onclick="resetTransfer()" disabled>é‡ç½®</button>
                        </div>
                    </div>
                </div>

                <div class="progress-container">
                    <div class="progress-bar" id="progressBar">0%</div>
                </div>

                <div id="transferStats" style="display: none;">
                    <div class="stat-item">
                        <span class="stat-label">å·²å‘é€å¸§æ•°:</span>
                        <span class="stat-value" id="framesSent">0/61</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">å·²ç¡®è®¤å¸§æ•°:</span>
                        <span class="stat-value" id="framesAck">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">NAKè®¡æ•°:</span>
                        <span class="stat-value" id="nakCount">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">é‡è¯•æ¬¡æ•°:</span>
                        <span class="stat-value" id="retryCount">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">ä¼ è¾“æ—¶é—´:</span>
                        <span class="stat-value" id="transferTime">0ç§’</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">ä¼ è¾“é€Ÿç‡:</span>
                        <span class="stat-value" id="transferRate">0 KB/s</span>
                    </div>
                </div>

                <div id="statusMsg" class="info-box">ç­‰å¾…æ“ä½œ...</div>
            </div>

            <!-- é«˜çº§è®¾ç½®æ ‡ç­¾é¡µ -->
            <div id="advancedSettings" class="tab-content">
                <div class="checkbox-group">
                    <div class="checkbox-item">
                        <input type="checkbox" id="showTimestamp" checked>
                        <label for="showTimestamp">æ˜¾ç¤ºæ—¶é—´æˆ³</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showSentData">
                        <label for="showSentData">æ˜¾ç¤ºå‘é€æ•°æ®</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showReceivedData">
                        <label for="showReceivedData">æ˜¾ç¤ºæ¥æ”¶æ•°æ®</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="enableDebug">
                        <label for="enableDebug">è°ƒè¯•æ¨¡å¼</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="autoScroll" checked>
                        <label for="autoScroll">è‡ªåŠ¨æ»šåŠ¨</label>
                    </div>
                </div>

                <div class="settings" style="margin-top: 15px;">
                    <div class="control-group">
                        <label>æ—¥å¿—çº§åˆ«</label>
                        <select id="logLevel">
                            <option value="verbose">è¯¦ç»† (Verbose)</option>
                            <option value="debug">è°ƒè¯• (Debug)</option>
                            <option value="info" selected>ä¿¡æ¯ (Info)</option>
                            <option value="warning">è­¦å‘Š (Warning)</option>
                            <option value="error">é”™è¯¯ (Error)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>æ˜¾ç¤ºæ¨¡å¼</label>
                        <select id="displayMode">
                            <option value="hex">åå…­è¿›åˆ¶ (HEX)</option>
                            <option value="ascii" selected>ASCII</option>
                            <option value="mixed">æ··åˆ</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>&nbsp;</label>
                        <button onclick="clearLog()">æ¸…ç©ºæ—¥å¿—</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- æ•°æ®å‘é€ -->
        <div class="panel">
            <div class="section-title">ğŸ“¤ æ•°æ®å‘é€</div>
            <div class="control-group">
                <label>å‘é€æ•°æ® (HEXæ ¼å¼ï¼Œç©ºæ ¼åˆ†éš”)</label>
                <textarea id="sendData" placeholder="ä¾‹å¦‚: 55 01 56 AA"></textarea>
            </div>
            <div class="btn-group">
                <button onclick="sendHexData()">å‘é€HEX</button>
                <button onclick="sendTextData()">å‘é€æ–‡æœ¬</button>
            </div>
        </div>

        <!-- æ•°æ®æ¥æ”¶ -->
        <div class="panel">
            <div class="section-title">ğŸ“¥ æ•°æ®æ¥æ”¶</div>
            <div class="settings">
                <div class="control-group">
                    <label>æ¥æ”¶æ•°æ® (<span id="recvSize">0</span> å­—èŠ‚)</label>
                </div>
                <div class="control-group">
                    <label>æ˜¾ç¤ºæ¨¡å¼</label>
                    <select id="recvDisplayMode">
                        <option value="text">æ–‡æœ¬ (TEXT)</option>
                        <option value="hex">16è¿›åˆ¶ (HEX)</option>
                        <option value="mixed">æ··åˆ (TEXT | HEX)</option>
                    </select>
                </div>
            </div>
            <div class="control-group">
                <textarea id="receiveData" readonly></textarea>
            </div>
            <div class="btn-group">
                <button onclick="clearReceivedData()">æ¸…ç©ºæ¥æ”¶</button>
                <button onclick="downloadReceivedData()">ä¸‹è½½</button>
            </div>
        </div>

        <!-- è°ƒè¯•æ—¥å¿— -->
        <div class="panel">
            <div class="section-title">ğŸ“‹ è°ƒè¯•æ—¥å¿—</div>
            <div class="control-group">
                <label>æ—¥å¿— (<span id="logLines">0</span> è¡Œ)</label>
                <textarea id="logArea" readonly></textarea>
            </div>
            <div class="btn-group">
                <button onclick="clearLog()">æ¸…ç©º</button>
                <button onclick="downloadLog()">ä¸‹è½½</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== å…¨å±€å˜é‡ ====================
        let port = null;
        let isConnected = false;
        let isTransferring = false;
        let imageData = null;
        let processedImageData = null;
        let receivedData = new Uint8Array(0);
        let transferStats = {
            framesSent: 0,
            framesAck: 0,
            nakCount: 0,
            retryCount: 0,
            startTime: 0,
            transferTime: 0
        };

        // å›¾åƒå˜æ¢å‚æ•°
        let imageOffsetX = 0;
        let imageOffsetY = 0;
        let imageScale = 1.0;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let currentProcessMode = null; // 'binarize', 'edge', 'invert', 'dither'

        // æ¥æ”¶æ•°æ®ç¼“å­˜ï¼ˆä¿å­˜åŸå§‹æ•°æ®ç”¨äºæ˜¾ç¤ºæ¨¡å¼åˆ‡æ¢ï¼‰
        let receivedDataBuffer = new Uint8Array(0);

        // åè®®å¸¸é‡
        const PROTO_START_MARK = 0x55;
        const PROTO_STOP_MARK = 0xAA;
        const CMD_START = 0x01;
        const CMD_END = 0x02;
        const CMD_READY = 0x03;
        const CMD_COMPLETE = 0x04;
        const CMD_FAIL = 0x05;
        const FRAME_TYPE_IMAGE_HEADER = 0x11;
        const FRAME_TYPE_IMAGE_DATA = 0x10;
        const RESP_ACK = 0x20;
        const RESP_NAK = 0x21;

        const IMAGE_PAGES = 61;
        const FRAME_PAYLOAD_SIZE = 248;
        const FRAME_TIMEOUT_MS = 3000;
        const CTRL_TIMEOUT_MS = 5000;

        // ä¼ è¾“çŠ¶æ€
        let lastAckFrame = -1;
        let waitingForAck = false;
        let ackPromiseResolve = null;

        // ==================== å·¥å…·å‡½æ•° ====================

        function log(message, level = 'info') {
            const logLevel = document.getElementById('logLevel').value;
            const levels = { verbose: 0, debug: 1, info: 2, warning: 3, error: 4 };
            if (levels[level] < levels[logLevel]) return;

            const logArea = document.getElementById('logArea');
            let timestamp = '';
            if (document.getElementById('showTimestamp').checked) {
                const now = new Date();
                timestamp = `[${now.toLocaleTimeString()}] `;
            }

            let prefix = '';
            switch(level) {
                case 'error': prefix = 'âŒ '; break;
                case 'warning': prefix = 'âš ï¸ '; break;
                case 'success': prefix = 'âœ… '; break;
                case 'debug': prefix = 'ğŸ› '; break;
                default: prefix = 'â„¹ï¸ '; break;
            }

            logArea.value += `${timestamp}${prefix}${message}\n`;
            const lines = logArea.value.split('\n').length - 1;
            document.getElementById('logLines').textContent = lines;

            if (document.getElementById('autoScroll').checked) {
                logArea.scrollTop = logArea.scrollHeight;
            }
        }

        function clearLog() {
            document.getElementById('logArea').value = '';
            document.getElementById('logLines').textContent = '0';
        }

        function updateStatus(message, type = 'info') {
            const statusMsg = document.getElementById('statusMsg');
            let timestamp = '';
            if (document.getElementById('showTimestamp').checked) {
                timestamp = new Date().toLocaleTimeString();
            }
            const icons = {
                error: 'âŒ',
                success: 'âœ…',
                warning: 'âš ï¸',
                info: 'â„¹ï¸'
            };
            statusMsg.textContent = `${icons[type]} ${timestamp} ${message}`;
            statusMsg.className = type === 'error' ? 'error-box' :
                                 type === 'success' ? 'success-box' :
                                 type === 'warning' ? 'warning-box' : 'info-box';
            log(message, type);
        }

        function switchTab(event, tabName) {
            const tabs = document.querySelectorAll('.tab');
            const contents = document.querySelectorAll('.tab-content');

            tabs.forEach(tab => tab.classList.remove('active'));
            contents.forEach(content => content.classList.remove('active'));

            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
        }

        // ==================== CRC & æ ¡éªŒ ====================

        function calculateCRC32(data) {
            let crc = 0xFFFFFFFF;
            for (let i = 0; i < data.length; i++) {
                crc ^= data[i];
                for (let j = 0; j < 8; j++) {
                    if (crc & 1) {
                        crc = (crc >>> 1) ^ 0xEDB88320;
                    } else {
                        crc = crc >>> 1;
                    }
                }
            }
            return (crc ^ 0xFFFFFFFF) >>> 0;
        }

        function calculateChecksum(data) {
            let sum = 0;
            for (let i = 0; i < data.length; i++) {
                sum = (sum + data[i]) & 0xFF;
            }
            return sum;
        }

        // ==================== ä¸²å£æ“ä½œ ====================

        async function connectSerial() {
            try {
                port = await navigator.serial.requestPort();
                const baudRate = parseInt(document.getElementById('baudRate').value);
                const dataBits = parseInt(document.getElementById('dataBits').value);
                const parity = document.getElementById('parity').value;
                const stopBits = parseInt(document.getElementById('stopBits').value);

                const options = {
                    baudRate,
                    dataBits,
                    parity,
                    stopBits
                };

                if (document.getElementById('flowControl').value === 'hardware') {
                    options.flowControl = 'hardware';
                }

                await port.open(options);
                isConnected = true;

                document.getElementById('connectBtn').disabled = true;
                document.getElementById('disconnectBtn').disabled = false;
                document.getElementById('previewBtn').disabled = false;
                document.getElementById('processBtn').disabled = false;
                document.getElementById('sendBtn').disabled = false;

                // å¯ç”¨RTSæ§åˆ¶å•é€‰æŒ‰é’®
                document.getElementById('rtsLow').disabled = false;
                document.getElementById('rtsHigh').disabled = false;

                document.getElementById('statusLight').className = 'status-indicator status-connected';
                document.getElementById('statusText').textContent = 'åœ¨çº¿';

                updateStatus(`ä¸²å£å·²è¿æ¥ (${baudRate} baud, ${dataBits}N${stopBits})`, 'success');
                startReadLoop();
            } catch (err) {
                updateStatus('è¿æ¥å¤±è´¥: ' + err.message, 'error');
            }
        }

        function disconnectSerial() {
            if (port) {
                port.close();
                isConnected = false;
                document.getElementById('connectBtn').disabled = false;
                document.getElementById('disconnectBtn').disabled = true;
                // ç¦ç”¨RTSæ§åˆ¶å•é€‰æŒ‰é’®
                document.getElementById('rtsLow').disabled = true;
                document.getElementById('rtsHigh').disabled = true;
                document.getElementById('statusLight').className = 'status-indicator status-disconnected';
                document.getElementById('statusText').textContent = 'ç¦»çº¿';
                updateStatus('ä¸²å£å·²æ–­å¼€', 'info');
            }
        }

        async function startReadLoop() {
            if (!port || !port.readable) return;
            const reader = port.readable.getReader();
            try {
                while (isConnected) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    if (value) {
                        handleReceivedData(value);
                    }
                }
            } catch (err) {
                log('è¯»å–é”™è¯¯: ' + err.message, 'error');
            } finally {
                reader.releaseLock();
            }
        }

        function handleReceivedData(data) {
            // è¿½åŠ æ¥æ”¶æ•°æ®åˆ°ç¼“å­˜
            const newData = new Uint8Array(receivedDataBuffer.length + data.length);
            newData.set(receivedDataBuffer);
            newData.set(data, receivedDataBuffer.length);
            receivedDataBuffer = newData;

            // åŒæ—¶æ›´æ–°å…¼å®¹çš„receivedData
            receivedData = receivedDataBuffer;

            // å°è¯•è§£æåè®®å“åº”å¸§
            parseProtocolFrames(data);

            // æ˜¾ç¤ºæ¥æ”¶æ•°æ®ï¼ˆç”¨äºæ—¥å¿—ï¼‰
            if (document.getElementById('showReceivedData').checked) {
                const displayMode = document.getElementById('displayMode').value;
                let displayStr = '';

                if (displayMode === 'hex' || displayMode === 'mixed') {
                    displayStr = Array.from(data).map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' ');
                }
                if (displayMode === 'ascii' || displayMode === 'mixed') {
                    if (displayMode === 'mixed') displayStr += ' | ';
                    displayStr += String.fromCharCode.apply(null, data);
                }

                log('RX: ' + displayStr, 'debug');
            }

            // æ›´æ–°æ¥æ”¶æ•°æ®æ˜¾ç¤ºæ¡†
            updateReceivedDataDisplay();
            document.getElementById('recvSize').textContent = receivedDataBuffer.length;
        }

        function parseProtocolFrames(data) {
            // æŸ¥æ‰¾æ§åˆ¶å¸§å’Œåº”ç­”å¸§
            for (let i = 0; i < data.length; i++) {
                if (data[i] === PROTO_START_MARK && i + 3 < data.length) {
                    // å¯èƒ½æ˜¯4å­—èŠ‚æ§åˆ¶å¸§
                    if (i + 3 < data.length && data[i + 3] === PROTO_STOP_MARK) {
                        const cmd = data[i + 1];
                        const checksum = data[i + 2];
                        const expectedChecksum = (data[i] + cmd) & 0xFF;

                        if (checksum === expectedChecksum) {
                            handleControlFrame(cmd);
                            continue;
                        }
                    }

                    // å¯èƒ½æ˜¯6å­—èŠ‚åº”ç­”å¸§ (ACK/NAK)
                    if (i + 5 < data.length && data[i + 5] === PROTO_STOP_MARK) {
                        const respType = data[i + 1];
                        const frameNum = data[i + 2] | (data[i + 3] << 8);
                        const checksum = data[i + 4];
                        const expectedChecksum = (data[i] + respType + data[i + 2] + data[i + 3]) & 0xFF;

                        if ((respType === RESP_ACK || respType === RESP_NAK) && checksum === expectedChecksum) {
                            handleResponseFrame(respType, frameNum);
                            continue;
                        }
                    }
                }
            }
        }

        function handleControlFrame(cmd) {
            if (cmd === CMD_READY) {
                log('ğŸ”µ å•ç‰‡æœºå·²å‡†å¤‡å¥½æ¥æ”¶', 'success');
                if (ackPromiseResolve) {
                    ackPromiseResolve({ type: 'READY' });
                    ackPromiseResolve = null;
                    waitingForAck = false;
                }
            } else if (cmd === CMD_COMPLETE) {
                log('âœ… å•ç‰‡æœºå·²ç¡®è®¤ä¼ è¾“å®Œæˆ', 'success');
                if (ackPromiseResolve) {
                    ackPromiseResolve({ type: 'COMPLETE', status: 'success' });
                    ackPromiseResolve = null;
                    waitingForAck = false;
                }
            } else if (cmd === CMD_FAIL) {
                log('âŒ å•ç‰‡æœºæ£€éªŒå¤±è´¥ï¼Œå­˜åœ¨ç¼ºå¤±å¸§', 'error');
                if (ackPromiseResolve) {
                    ackPromiseResolve({ type: 'FAIL', status: 'fail' });
                    ackPromiseResolve = null;
                    waitingForAck = false;
                }
            }
        }

        function handleResponseFrame(respType, frameNum) {
            if (respType === RESP_ACK) {
                log(`âœ… å¸§${frameNum}å·²ç¡®è®¤ (ACK)`, 'success');
                lastAckFrame = frameNum;
                transferStats.framesAck++;
                document.getElementById('framesAck').textContent = transferStats.framesAck;

                if (ackPromiseResolve) {
                    ackPromiseResolve({ type: 'ACK', frameNum: frameNum });
                    ackPromiseResolve = null;
                    waitingForAck = false;
                }
            } else if (respType === RESP_NAK) {
                log(`âŒ å¸§${frameNum}éœ€è¦é‡ä¼  (NAK)`, 'warning');
                transferStats.nakCount++;
                document.getElementById('nakCount').textContent = transferStats.nakCount;

                if (ackPromiseResolve) {
                    ackPromiseResolve({ type: 'NAK', frameNum: frameNum });
                    ackPromiseResolve = null;
                    waitingForAck = false;
                }
            }
        }

        function updateReceivedDataDisplay() {
            const displayMode = document.getElementById('recvDisplayMode').value;
            let displayStr = '';

            if (displayMode === 'text') {
                // æ–‡æœ¬æ¨¡å¼
                displayStr = String.fromCharCode.apply(null, receivedDataBuffer);
            } else if (displayMode === 'hex') {
                // 16è¿›åˆ¶æ¨¡å¼
                displayStr = Array.from(receivedDataBuffer)
                    .map(b => b.toString(16).padStart(2, '0').toUpperCase())
                    .join(' ');
            } else if (displayMode === 'mixed') {
                // æ··åˆæ¨¡å¼ï¼šHEX | ASCII
                const hexStr = Array.from(receivedDataBuffer)
                    .map(b => b.toString(16).padStart(2, '0').toUpperCase())
                    .join(' ');
                const asciiStr = String.fromCharCode.apply(null, receivedDataBuffer);
                displayStr = hexStr + '\n\n--- æ–‡æœ¬æ˜¾ç¤º ---\n' + asciiStr;
            }

            document.getElementById('receiveData').value = displayStr;
        }

        async function sendFrame(frame) {
            if (!port || !port.writable) {
                throw new Error('ä¸²å£æœªè¿æ¥');
            }

            if (document.getElementById('showSentData').checked) {
                const displayMode = document.getElementById('displayMode').value;
                let displayStr = '';

                if (displayMode === 'hex' || displayMode === 'mixed') {
                    displayStr = Array.from(frame).map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' ');
                }
                if (displayMode === 'ascii' || displayMode === 'mixed') {
                    if (displayMode === 'mixed') displayStr += ' | ';
                    displayStr += String.fromCharCode.apply(null, frame);
                }

                log('TX: ' + displayStr, 'debug');
            }

            const writer = port.writable.getWriter();
            try {
                await writer.write(frame);
            } finally {
                writer.releaseLock();
            }
        }

        // ==================== æ‰‹åŠ¨æ•°æ®å‘é€ ====================

        async function sendHexData() {
            if (!isConnected) {
                updateStatus('ä¸²å£æœªè¿æ¥', 'error');
                return;
            }

            try {
                const hexStr = document.getElementById('sendData').value;
                const bytes = hexStr.trim().split(/\s+/).map(h => parseInt(h, 16));

                if (bytes.some(isNaN)) {
                    updateStatus('HEXæ ¼å¼é”™è¯¯', 'error');
                    return;
                }

                await sendFrame(new Uint8Array(bytes));
                updateStatus(`å·²å‘é€ ${bytes.length} å­—èŠ‚`, 'success');
            } catch (err) {
                updateStatus('å‘é€å¤±è´¥: ' + err.message, 'error');
            }
        }

        async function sendTextData() {
            if (!isConnected) {
                updateStatus('ä¸²å£æœªè¿æ¥', 'error');
                return;
            }

            try {
                const text = document.getElementById('sendData').value;
                const bytes = new Uint8Array(text.length);
                for (let i = 0; i < text.length; i++) {
                    bytes[i] = text.charCodeAt(i);
                }

                await sendFrame(bytes);
                updateStatus(`å·²å‘é€ ${text.length} å­—èŠ‚`, 'success');
            } catch (err) {
                updateStatus('å‘é€å¤±è´¥: ' + err.message, 'error');
            }
        }

        function clearReceivedData() {
            receivedData = new Uint8Array(0);
            receivedDataBuffer = new Uint8Array(0);
            document.getElementById('receiveData').value = '';
            document.getElementById('recvSize').textContent = '0';
            updateStatus('æ¥æ”¶æ•°æ®å·²æ¸…ç©º', 'info');
        }

        function downloadReceivedData() {
            const text = document.getElementById('receiveData').value;
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `received_${new Date().getTime()}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function downloadLog() {
            const text = document.getElementById('logArea').value;
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `log_${new Date().getTime()}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // ==================== å›¾åƒå¤„ç† ====================

        function previewImage() {
            const fileInput = document.getElementById('imageInput');
            if (!fileInput.files.length) {
                updateStatus('è¯·å…ˆé€‰æ‹©å›¾åƒæ–‡ä»¶', 'error');
                return;
            }

            const file = fileInput.files[0];
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    imageData = img;
                    resetImageTransform();
                    drawPreview(img);
                    document.getElementById('processBtn').disabled = false;
                    updateStatus(`å›¾åƒå·²åŠ è½½: ${img.width}x${img.height}ï¼Œå¯æ‹–åŠ¨è°ƒæ•´ä½ç½®`, 'success');
                    document.getElementById('imageInfo').innerHTML = `
                        <strong>å›¾åƒä¿¡æ¯:</strong><br>
                        æ–‡ä»¶å: ${file.name}<br>
                        å°ºå¯¸: ${img.width}x${img.height} px<br>
                        å¤§å°: ${(file.size / 1024).toFixed(2)} KB<br>
                        ç±»å‹: ${file.type}
                    `;
                    document.getElementById('imageInfo').style.display = 'block';
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function resetImageTransform() {
            // è®¡ç®—åˆå§‹ç¼©æ”¾æ¯”ä¾‹ï¼Œä½¿å›¾åƒé€‚é…400x300ç”»å¸ƒ
            const imageWidth = parseInt(document.getElementById('imageWidth').value);
            const imageHeight = parseInt(document.getElementById('imageHeight').value);
            if (imageData) {
                const scaleX = imageWidth / imageData.width;
                const scaleY = imageHeight / imageData.height;
                imageScale = Math.max(scaleX, scaleY); // ä½¿ç”¨maxä»¥ç¡®ä¿å›¾åƒè‡³å°‘è¦†ç›–æ•´ä¸ªç”»å¸ƒ
            }
            imageOffsetX = 0;
            imageOffsetY = 0;
        }

        function drawPreview(img) {
            const canvas = document.getElementById('previewCanvas');
            const width = parseInt(document.getElementById('imageWidth').value);
            const height = parseInt(document.getElementById('imageHeight').value);
            canvas.width = width;
            canvas.height = height;

            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, width, height);

            const scaleMode = document.getElementById('scaleMode').value;
            let scale, x = 0, y = 0;

            if (scaleMode === 'fit') {
                scale = Math.min(width / img.width, height / img.height);
                x = (width - img.width * scale) / 2;
                y = (height - img.height * scale) / 2;
                ctx.drawImage(img, x, y, img.width * scale, img.height * scale);
            } else if (scaleMode === 'fill') {
                scale = Math.max(width / img.width, height / img.height);
                x = (width - img.width * scale) / 2;
                y = (height - img.height * scale) / 2;
                ctx.drawImage(img, x, y, img.width * scale, img.height * scale);
            } else {
                ctx.drawImage(img, 0, 0, width, height);
            }
        }

        function showCropSettings() {
            const enable = document.getElementById('enableCrop').checked;
            document.getElementById('cropSettings').style.display = enable ? 'block' : 'none';
        }

        function applyImageProcessing() {
            if (!imageData) {
                updateStatus('è¯·å…ˆé¢„è§ˆå›¾åƒ', 'error');
                return;
            }

            // ç¡®å®šå½“å‰å¤„ç†æ¨¡å¼
            if (document.getElementById('enableBinarize').checked) {
                currentProcessMode = 'binarize';
            } else if (document.getElementById('enableLineExtract').checked) {
                currentProcessMode = 'edge';
            } else {
                currentProcessMode = 'other';
            }

            resetImageTransform();
            redrawProcessedImage();
            updateStatus('å›¾åƒå¤„ç†å®Œæˆï¼Œå¯æ‹–åŠ¨è°ƒæ•´ä½ç½® | é¼ æ ‡æ»šè½®ç¼©æ”¾', 'success');
        }

        function redrawProcessedImage() {
            if (!imageData || !currentProcessMode) return;

            const processedCanvas = document.getElementById('processedCanvas');
            const imageWidth = parseInt(document.getElementById('imageWidth').value);
            const imageHeight = parseInt(document.getElementById('imageHeight').value);

            processedCanvas.width = imageWidth;
            processedCanvas.height = imageHeight;

            const ctx = processedCanvas.getContext('2d');
            ctx.clearRect(0, 0, imageWidth, imageHeight);
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, imageWidth, imageHeight);

            // è®¡ç®—ç»˜åˆ¶ä½ç½®å’Œå¤§å°
            const scaledWidth = imageData.width * imageScale;
            const scaledHeight = imageData.height * imageScale;
            const x = (imageWidth - scaledWidth) / 2 + imageOffsetX;
            const y = (imageHeight - scaledHeight) / 2 + imageOffsetY;

            ctx.drawImage(imageData, x, y, scaledWidth, scaledHeight);

            // è·å–ç”»å¸ƒæ•°æ®ç”¨äºå¤„ç†
            let imageData_obj = ctx.getImageData(0, 0, imageWidth, imageHeight);

            // åè‰²
            if (document.getElementById('enableInvert').checked) {
                for (let i = 0; i < imageData_obj.data.length; i += 4) {
                    imageData_obj.data[i] = 255 - imageData_obj.data[i];
                    imageData_obj.data[i+1] = 255 - imageData_obj.data[i+1];
                    imageData_obj.data[i+2] = 255 - imageData_obj.data[i+2];
                }
            }

            // çº¿ç¨¿æå–ï¼ˆè¾¹ç¼˜æ£€æµ‹ï¼‰
            if (document.getElementById('enableLineExtract').checked) {
                imageData_obj = sobelEdgeDetection(imageData_obj);
            }

            // äºŒå€¼åŒ–
            if (document.getElementById('enableBinarize').checked) {
                const threshold = parseInt(document.getElementById('binarizeThreshold').value);
                for (let i = 0; i < imageData_obj.data.length; i += 4) {
                    const gray = imageData_obj.data[i] * 0.299 + imageData_obj.data[i+1] * 0.587 + imageData_obj.data[i+2] * 0.114;
                    const value = gray > threshold ? 255 : 0;
                    imageData_obj.data[i] = value;
                    imageData_obj.data[i+1] = value;
                    imageData_obj.data[i+2] = value;
                }
            }

            // æŠ–åŠ¨
            if (document.getElementById('enableDither').checked) {
                imageData_obj = floydSteinbergDither(imageData_obj);
            }

            ctx.putImageData(imageData_obj, 0, 0);
            processedImageData = imageData_obj;
        }

        function sobelEdgeDetection(imageData) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const output = new ImageData(width, height);
            const outData = output.data;

            const Gx = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]];
            const Gy = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]];

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let sumX = 0, sumY = 0;

                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const idx = ((y + dy) * width + (x + dx)) * 4;
                            const gray = data[idx] * 0.299 + data[idx+1] * 0.587 + data[idx+2] * 0.114;
                            sumX += gray * Gx[dy + 1][dx + 1];
                            sumY += gray * Gy[dy + 1][dx + 1];
                        }
                    }

                    const magnitude = Math.sqrt(sumX * sumX + sumY * sumY);
                    const value = Math.min(255, Math.max(0, magnitude));
                    const idx = (y * width + x) * 4;
                    outData[idx] = value;
                    outData[idx + 1] = value;
                    outData[idx + 2] = value;
                    outData[idx + 3] = 255;
                }
            }

            return output;
        }

        function floydSteinbergDither(imageData) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const output = new ImageData(width, height);
            const outData = output.data;

            outData.set(data);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const gray = outData[idx];
                    const newValue = gray > 128 ? 255 : 0;
                    const error = gray - newValue;

                    outData[idx] = newValue;
                    outData[idx + 1] = newValue;
                    outData[idx + 2] = newValue;

                    // åˆ†æ•£è¯¯å·®åˆ°ç›¸é‚»åƒç´ 
                    if (x + 1 < width) {
                        const idx1 = (y * width + x + 1) * 4;
                        outData[idx1] = Math.min(255, outData[idx1] + error * 7 / 16);
                    }
                    if (y + 1 < height) {
                        if (x > 0) {
                            const idx2 = ((y + 1) * width + x - 1) * 4;
                            outData[idx2] = Math.min(255, outData[idx2] + error * 3 / 16);
                        }
                        const idx3 = ((y + 1) * width + x) * 4;
                        outData[idx3] = Math.min(255, outData[idx3] + error * 5 / 16);
                        if (x + 1 < width) {
                            const idx4 = ((y + 1) * width + x + 1) * 4;
                            outData[idx4] = Math.min(255, outData[idx4] + error * 1 / 16);
                        }
                    }
                }
            }

            return output;
        }

        // ==================== å¸§æ„å»º ====================

        function buildControlFrame(command) {
            const frame = new Uint8Array(4);
            frame[0] = PROTO_START_MARK;
            frame[1] = command;
            frame[2] = calculateChecksum(frame.slice(0, 2));
            frame[3] = PROTO_STOP_MARK;
            return frame;
        }

        function buildDataFrame(frameType, frameNum, slotId, payload) {
            const frame = new Uint8Array(259);
            let offset = 0;

            frame[offset++] = PROTO_START_MARK;
            frame[offset++] = frameType;
            frame[offset++] = frameNum & 0xFF;
            frame[offset++] = (frameNum >> 8) & 0xFF;
            frame[offset++] = slotId;

            const crc = calculateCRC32(payload);
            frame[offset++] = crc & 0xFF;
            frame[offset++] = (crc >> 8) & 0xFF;
            frame[offset++] = (crc >> 16) & 0xFF;
            frame[offset++] = (crc >> 24) & 0xFF;

            frame.set(payload, offset);
            offset += FRAME_PAYLOAD_SIZE;

            frame[offset++] = calculateChecksum(frame.slice(0, 257));
            frame[offset++] = PROTO_STOP_MARK;

            return frame;
        }

        // ==================== å›¾åƒå‘é€ ====================

        async function sendImage() {
            if (!isConnected || !processedImageData) {
                updateStatus('æœªå‡†å¤‡å¥½æˆ–å›¾åƒæœªå¤„ç†', 'error');
                return;
            }

            isTransferring = true;
            document.getElementById('sendBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('resetBtn').disabled = false;
            document.getElementById('transferStats').style.display = 'block';

            transferStats = {
                framesSent: 0,
                framesAck: 0,
                nakCount: 0,
                retryCount: 0,
                startTime: Date.now(),
                transferTime: 0
            };

            try {
                const slotId = parseInt(document.getElementById('slotId').value);
                const maxRetries = parseInt(document.getElementById('maxRetries').value);

                // ===== æ­¥éª¤1: å‘é€STARTå¹¶ç­‰å¾…READY =====
                log('ğŸ“¤ å‘é€STARTå‘½ä»¤', 'info');
                await sendControlFrameAndWait(CMD_START, CMD_READY, CTRL_TIMEOUT_MS);
                updateStatus('âœ… å•ç‰‡æœºå·²å‡†å¤‡å¥½', 'success');

                // ===== æ­¥éª¤2: å‘é€å›¾åƒå¤´å¹¶ç­‰å¾…ACK =====
                log('ğŸ“¤ å‘é€å›¾åƒå¤´', 'info');
                const headerPayload = new Uint8Array(FRAME_PAYLOAD_SIZE).fill(0xFF);
                await sendDataFrameAndWaitAck(FRAME_TYPE_IMAGE_HEADER, 0, slotId, headerPayload, maxRetries);

                // ===== æ­¥éª¤3: å‘é€61å¸§æ•°æ® =====
                log('ğŸ“¤ å¼€å§‹å‘é€å›¾åƒæ•°æ® (61å¸§)...', 'info');
                const imageBytes = convertImageToBytes(processedImageData);

                for (let i = 0; i < IMAGE_PAGES; i++) {
                    if (!isTransferring) {
                        log('âŒ ä¼ è¾“è¢«ç”¨æˆ·ä¸­æ­¢', 'warning');
                        break;
                    }

                    const start = i * FRAME_PAYLOAD_SIZE;
                    const end = Math.min(start + FRAME_PAYLOAD_SIZE, imageBytes.length);
                    const pageData = new Uint8Array(FRAME_PAYLOAD_SIZE);
                    pageData.set(imageBytes.slice(start, end));
                    if (end - start < FRAME_PAYLOAD_SIZE) {
                        pageData.fill(0xFF, end - start);
                    }

                    // å‘é€è¿™ä¸€å¸§å¹¶ç­‰å¾…ACK (å¯èƒ½é‡è¯•å¤šæ¬¡)
                    try {
                        await sendDataFrameAndWaitAck(FRAME_TYPE_IMAGE_DATA, i, slotId, pageData, maxRetries);

                        const progress = ((i + 1) / IMAGE_PAGES * 100).toFixed(1);
                        document.getElementById('progressBar').style.width = progress + '%';
                        document.getElementById('progressBar').textContent = progress + '%';
                        document.getElementById('framesSent').textContent = (i + 1) + '/61';
                        updateStatus(`å·²ä¼ è¾“ ${i + 1}/61 å¸§ (${progress}%)`, 'info');
                    } catch (err) {
                        log(`âŒ å¸§${i}ä¼ è¾“å¤±è´¥: ${err.message}`, 'error');
                        updateStatus(`âŒ å¸§${i}ä¼ è¾“å¤±è´¥`, 'error');
                        break;
                    }
                }

                if (!isTransferring) {
                    return;
                }

                // ===== æ­¥éª¤4: å‘é€ENDå¹¶ç­‰å¾…COMPLETE/FAIL =====
                log('ğŸ“¤ å‘é€ENDå‘½ä»¤ï¼Œç­‰å¾…å•ç‰‡æœºéªŒè¯å®Œæ•´æ€§...', 'info');
                const result = await sendControlFrameAndWaitResult(CMD_END, CTRL_TIMEOUT_MS);

                if (result.status === 'success') {
                    log('âœ… å•ç‰‡æœºéªŒè¯æˆåŠŸï¼Œæ‰€æœ‰å¸§å®Œæ•´', 'success');
                    updateStatus('âœ… ä¼ è¾“å®Œæˆä¸”éªŒè¯æˆåŠŸï¼', 'success');
                } else {
                    log('âŒ å•ç‰‡æœºéªŒè¯å¤±è´¥ï¼Œå­˜åœ¨ç¼ºå¤±å¸§', 'error');
                    updateStatus('âŒ ä¼ è¾“å®Œæˆä½†éªŒè¯å¤±è´¥ï¼Œå­˜åœ¨ç¼ºå¤±å¸§', 'error');
                }

                transferStats.transferTime = (Date.now() - transferStats.startTime) / 1000;
                const transferredBytes = (transferStats.framesSent) * 259;
                const rate = transferredBytes > 0 ? (transferredBytes / 1024 / transferStats.transferTime).toFixed(2) : 0;
                document.getElementById('transferTime').textContent = transferStats.transferTime.toFixed(2) + 'ç§’';
                document.getElementById('transferRate').textContent = rate + ' KB/s';

            } catch (err) {
                updateStatus('âŒ ä¼ è¾“å¤±è´¥: ' + err.message, 'error');
                log('âŒ ä¼ è¾“å¼‚å¸¸: ' + err.message, 'error');
            } finally {
                isTransferring = false;
                document.getElementById('sendBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
            }
        }

        async function sendControlFrameAndWait(cmdSend, cmdWait, timeoutMs) {
            return new Promise((resolve, reject) => {
                waitingForAck = true;
                let timeoutHandle = null;

                ackPromiseResolve = (result) => {
                    clearTimeout(timeoutHandle);
                    if (result.type === cmdWait.toString() || (cmdWait === CMD_READY && result.type === 'READY')) {
                        resolve(result);
                    } else {
                        reject(new Error(`æœŸæœ› ${cmdWait}ï¼Œæ”¶åˆ° ${result.type}`));
                    }
                };

                timeoutHandle = setTimeout(() => {
                    waitingForAck = false;
                    ackPromiseResolve = null;
                    reject(new Error(`æ§åˆ¶å¸§è¶…æ—¶ (${timeoutMs}ms)`));
                }, timeoutMs);

                sendFrame(buildControlFrame(cmdSend)).catch(reject);
            });
        }

        async function sendControlFrameAndWaitResult(cmdSend, timeoutMs) {
            return new Promise((resolve, reject) => {
                waitingForAck = true;
                let timeoutHandle = null;

                ackPromiseResolve = (result) => {
                    clearTimeout(timeoutHandle);
                    if (result.type === 'COMPLETE' || result.type === 'FAIL') {
                        resolve(result);
                    } else {
                        reject(new Error(`æœŸæœ› COMPLETE/FAILï¼Œæ”¶åˆ° ${result.type}`));
                    }
                };

                timeoutHandle = setTimeout(() => {
                    waitingForAck = false;
                    ackPromiseResolve = null;
                    reject(new Error(`ç­‰å¾…COMPLETE/FAILè¶…æ—¶ (${timeoutMs}ms)`));
                }, timeoutMs);

                sendFrame(buildControlFrame(cmdSend)).catch(reject);
            });
        }

        async function sendDataFrameAndWaitAck(frameType, frameNum, slotId, payload, maxRetries) {
            for (let retry = 0; retry < maxRetries; retry++) {
                if (!isTransferring) {
                    throw new Error('ä¼ è¾“å·²ä¸­æ­¢');
                }

                return new Promise((resolve, reject) => {
                    waitingForAck = true;
                    let timeoutHandle = null;

                    ackPromiseResolve = (result) => {
                        clearTimeout(timeoutHandle);

                        if (result.type === 'ACK' && result.frameNum === frameNum) {
                            // ACKæˆåŠŸï¼Œè¿”å›
                            resolve();
                        } else if (result.type === 'NAK' && result.frameNum === frameNum) {
                            // NAKå¤±è´¥ï¼Œéœ€è¦é‡è¯•
                            waitingForAck = false;
                            ackPromiseResolve = null;
                            reject(new Error(`æ”¶åˆ°NAKï¼Œéœ€è¦é‡è¯•`));
                        } else {
                            // å…¶ä»–å“åº”ï¼Œå¿½ç•¥
                            ackPromiseResolve = null;
                            reject(new Error(`æœŸæœ›ACK/NAK for frame ${frameNum}ï¼Œæ”¶åˆ° ${result.type}`));
                        }
                    };

                    timeoutHandle = setTimeout(() => {
                        waitingForAck = false;
                        ackPromiseResolve = null;
                        if (retry < maxRetries - 1) {
                            reject(new Error(`å¸§${frameNum}è¶…æ—¶ï¼Œå°†é‡è¯•`));
                        } else {
                            reject(new Error(`å¸§${frameNum}é‡è¯•${maxRetries}æ¬¡å¤±è´¥`));
                        }
                    }, FRAME_TIMEOUT_MS);

                    const frame = buildDataFrame(frameType, frameNum, slotId, payload);
                    log(`ğŸ“¤ å‘é€å¸§${frameNum} (é‡è¯• ${retry + 1}/${maxRetries})`, 'debug');

                    sendFrame(frame).then(() => {
                        transferStats.framesSent++;
                        if (retry > 0) {
                            transferStats.retryCount++;
                            document.getElementById('retryCount').textContent = transferStats.retryCount;
                        }
                    }).catch(reject);
                });
            }
        }

        function convertImageToBytes(imageData) {
            const data = imageData.data;
            const bytes = new Uint8Array(imageData.width * imageData.height / 8);

            let byteIdx = 0;
            for (let i = 0; i < data.length; i += 32) {
                let byte = 0;
                for (let bit = 0; bit < 8 && i + bit * 4 < data.length; bit++) {
                    if (data[i + bit * 4] > 128) {
                        byte |= (1 << (7 - bit));
                    }
                }
                bytes[byteIdx++] = byte;
            }

            return bytes;
        }

        function stopTransfer() {
            isTransferring = false;
            updateStatus('ä¼ è¾“å·²åœæ­¢', 'warning');
        }

        function resetTransfer() {
            processedImageData = null;
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('progressBar').textContent = '0%';
            document.getElementById('transferStats').style.display = 'none';
            updateStatus('å·²é‡ç½®', 'info');
        }

        // ==================== å·¥å…· ====================

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // ==================== é˜ˆå€¼æ»‘å—äº‹ä»¶ ====================

        const thresholdSlider = document.getElementById('binarizeThresholdSlider');
        const thresholdInput = document.getElementById('binarizeThreshold');

        thresholdSlider.addEventListener('input', (e) => {
            const value = e.target.value;
            thresholdInput.value = value;
            if (currentProcessMode) {
                redrawProcessedImage();
            }
        });

        thresholdInput.addEventListener('input', (e) => {
            const value = Math.max(0, Math.min(255, parseInt(e.target.value) || 128));
            e.target.value = value;
            thresholdSlider.value = value;
            if (currentProcessMode) {
                redrawProcessedImage();
            }
        });

        // ==================== å›¾åƒå¤„ç†é€‰é¡¹äº‹ä»¶ ====================

        document.getElementById('enableBinarize').addEventListener('change', () => {
            if (currentProcessMode) {
                redrawProcessedImage();
            }
        });

        document.getElementById('enableLineExtract').addEventListener('change', () => {
            if (currentProcessMode) {
                redrawProcessedImage();
            }
        });

        document.getElementById('enableInvert').addEventListener('change', () => {
            if (currentProcessMode) {
                redrawProcessedImage();
            }
        });

        document.getElementById('enableDither').addEventListener('change', () => {
            if (currentProcessMode) {
                redrawProcessedImage();
            }
        });

        // ==================== ç”»å¸ƒé¼ æ ‡äº‹ä»¶ ====================

        const processedCanvas = document.getElementById('processedCanvas');

        // é¼ æ ‡æŒ‰ä¸‹ - å¼€å§‹æ‹–åŠ¨
        processedCanvas.addEventListener('mousedown', (e) => {
            if (!currentProcessMode) return;
            isDragging = true;
            const rect = processedCanvas.getBoundingClientRect();
            lastMouseX = e.clientX - rect.left;
            lastMouseY = e.clientY - rect.top;
            processedCanvas.style.cursor = 'grabbing';
        });

        // é¼ æ ‡ç§»åŠ¨ - æ‹–åŠ¨å›¾åƒ
        processedCanvas.addEventListener('mousemove', (e) => {
            if (!isDragging || !currentProcessMode) return;
            const rect = processedCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            imageOffsetX += mouseX - lastMouseX;
            imageOffsetY += mouseY - lastMouseY;

            lastMouseX = mouseX;
            lastMouseY = mouseY;

            redrawProcessedImage();
        });

        // é¼ æ ‡æŠ¬èµ· - åœæ­¢æ‹–åŠ¨
        processedCanvas.addEventListener('mouseup', () => {
            isDragging = false;
            processedCanvas.style.cursor = currentProcessMode ? 'grab' : 'default';
        });

        // é¼ æ ‡ç¦»å¼€ - åœæ­¢æ‹–åŠ¨
        processedCanvas.addEventListener('mouseleave', () => {
            isDragging = false;
            processedCanvas.style.cursor = 'default';
        });

        // é¼ æ ‡è¿›å…¥ - æ”¹å˜å…‰æ ‡
        processedCanvas.addEventListener('mouseenter', () => {
            if (currentProcessMode) {
                processedCanvas.style.cursor = 'grab';
            }
        });

        // æ»šè½®ç¼©æ”¾
        processedCanvas.addEventListener('wheel', (e) => {
            if (!currentProcessMode) return;
            e.preventDefault();

            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            imageScale *= delta;
            imageScale = Math.max(0.1, Math.min(5, imageScale)); // é™åˆ¶ç¼©æ”¾èŒƒå›´

            redrawProcessedImage();
        });

        // ==================== RTSæ§åˆ¶ ====================

        // RTSæ§åˆ¶ - æ‹‰ä½ (0)
        document.getElementById('rtsLow').addEventListener('change', async () => {
            if (document.getElementById('rtsLow').checked) {
                try {
                    if (!port || !port.setSignals) {
                        updateStatus('RTSæ§åˆ¶ä¸æ”¯æŒæˆ–ä¸²å£æœªè¿æ¥', 'error');
                        return;
                    }
                    // requestToSendä¸ºtrueæ—¶ï¼ŒRTSæ‹‰ä½ï¼ˆactive lowï¼‰
                    await port.setSignals({ requestToSend: true });
                    log('RTSå·²æ‹‰ä½ (0)', 'info');
                    updateStatus('RTSå·²æ‹‰ä½', 'success');
                } catch (err) {
                    log('RTSæ‹‰ä½å¤±è´¥: ' + err.message, 'error');
                    updateStatus('RTSæ‹‰ä½å¤±è´¥: ' + err.message, 'error');
                }
            }
        });

        // RTSæ§åˆ¶ - æ‹‰é«˜ (1)
        document.getElementById('rtsHigh').addEventListener('change', async () => {
            if (document.getElementById('rtsHigh').checked) {
                try {
                    if (!port || !port.setSignals) {
                        updateStatus('RTSæ§åˆ¶ä¸æ”¯æŒæˆ–ä¸²å£æœªè¿æ¥', 'error');
                        return;
                    }
                    // requestToSendä¸ºfalseæ—¶ï¼ŒRTSæ‹‰é«˜ï¼ˆinactive highï¼‰
                    await port.setSignals({ requestToSend: false });
                    log('RTSå·²æ‹‰é«˜ (1)', 'info');
                    updateStatus('RTSå·²æ‹‰é«˜', 'success');
                } catch (err) {
                    log('RTSæ‹‰é«˜å¤±è´¥: ' + err.message, 'error');
                    updateStatus('RTSæ‹‰é«˜å¤±è´¥: ' + err.message, 'error');
                }
            }
        });

        // ==================== æ¥æ”¶æ•°æ®æ˜¾ç¤ºæ¨¡å¼åˆ‡æ¢ ====================

        document.getElementById('recvDisplayMode').addEventListener('change', () => {
            updateReceivedDataDisplay();
        });

        // åˆå§‹åŒ–
        window.onload = () => {
            log('åº”ç”¨å·²å¯åŠ¨', 'info');
            updateStatus('å°±ç»ªï¼Œè¯·è¿æ¥ä¸²å£', 'info');
        };
    </script>
</body>
</html>
