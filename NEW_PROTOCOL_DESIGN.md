# 新图像传输协议设计（V2）

## 📋 协议概述

基于**分帧ACK机制**的可靠传输协议，参考XMODEM/Kermit思想。

### 特点
- ✅ 每帧独立验证（CRC校验）
- ✅ 上位机等待ACK再发下一帧
- ✅ 低缓冲需求（只需一帧缓冲）
- ✅ 错误重传机制
- ✅ 传输状态机清晰

---

## 🔄 协议流程

### 上位机流程
```
1. 发送START命令 → 等待READY
2. 计算CRC → 打包成帧 → 发送帧
3. 等待ACK/NAK/TIMEOUT
   ├─ 收到ACK → 发送下一帧
   ├─ 收到NAK → 重传当前帧
   └─ 超时 → 重传（最多5次）
4. 所有61帧完成 → 发送END命令
5. 等待COMPLETE
```

### 下位机流程
```
1. IDLE状态 → 等待START
2. 收到START → 发送READY
3. 等待数据帧
4. 收到完整帧 → CRC校验
   ├─ 成功 → 保存到Flash → 发送ACK
   ├─ 失败 → 发送NAK
   └─ 超时 → 不动作，上位机会超时重传
5. 重复63次（61帧图像+1帧头+1帧END）
```

---

## 🏗️ 帧结构设计

### 控制帧格式（用于START/END等）
```
字节位置   内容            长度    说明
0         START_MARK      1       0x55
1         COMMAND         1       0x01(START) / 0x02(END)
2         CHECKSUM        1       简单和校验
3         STOP_MARK       1       0xAA
────────────────────────────────────
总计                       4字节
```

### 数据帧格式（用于图像数据）
```
字节位置   内容            长度    说明
0         START_MARK      1       0x55
1         FRAME_TYPE      1       0x10(图像数据) / 0x11(图像头)
2-3       FRAME_NUM       2       帧号 (little-endian) [0-61]
4         SLOT_ID         1       图像槽位 [0-7]
5-8       CRC32           4       负载的CRC32 (little-endian)
9-256     PAYLOAD         248     图像数据或头信息
257       CHECKSUM        1       简单和校验
258       STOP_MARK       1       0xAA
────────────────────────────────────
总计                       259字节
```

### 应答帧格式
```
字节位置   内容            长度    说明
0         START_MARK      1       0x55
1         ACK_TYPE        1       0x20(ACK) / 0x21(NAK)
2         FRAME_NUM_L     1       帧号低字节
3         FRAME_NUM_H     1       帧号高字节
4         CHECKSUM        1       简单和校验
5         STOP_MARK       1       0xAA
────────────────────────────────────
总计                       6字节
```

---

## 📊 状态机详解

### 上位机状态机
```
IDLE
  ↓ 发送START
WAIT_READY
  ↓ 收到READY
SENDING_HEADER (发送图像头)
  ↓ 等待ACK
SENDING_DATA (发送61帧图像)
  ├─ 帧0-60逐个发送
  ├─ 每帧等待ACK
  └─ ACK失败则重传
SENDING_END
  ↓ 等待COMPLETE
COMPLETE ✓
```

### 下位机状态机
```
IDLE (等待START)
  ↓ 收到START → 发送READY
WAITING_HEADER
  ├─ 超时 → 发送NAK → 回到IDLE
  └─ 收到头帧 ✓ → 发送ACK
WAITING_DATA (等待图像帧0-60)
  ├─ 收到帧N → 验证 → 保存Flash → 发送ACK
  ├─ 验证失败 → 发送NAK → 等待重传
  └─ 超时 → 等待重传
TRANSFER_COMPLETE ✓
```

---

## 💾 缓冲设计

### 只需一帧缓冲
```c
// 下位机接收缓冲（单帧）
uint8_t rx_frame_buf[259];  // 接收缓冲
uint16_t rx_idx = 0;        // 当前位置
uint8_t rx_state = 0;       // 帧接收状态

// 临时存储
uint8_t current_frame_num;
uint8_t current_slot_id;
uint32_t current_crc;
uint8_t *payload_data;      // 指向缓冲中的有效载荷部分
```

### 数据流
```
接收到帧 → 验证 → 取出payload指针 → 写入Flash → 清空缓冲
```

---

## 🔄 流控与超时

### 超时设置
```
START_TIMEOUT:     5秒   （等待READY）
FRAME_TIMEOUT:     3秒   （等待ACK）
重传次数:          5次   （超过5次放弃）
```

### 流控机制
```
上位机                          下位机
发送帧 ─────────────────→ 接收帧
                          验证CRC
       ←───── ACK ────────
发送下一帧                清空缓冲
```

---

## 📝 完整通信序列

### 正常流程
```
上位机                                下位机
  │                                    │
  │───── START (4字节) ────────────→  │ 收到START
  │                                    │ 发送READY
  │←──── READY (4字节) ────────────   │
  │                                    │
  │───── HEADER帧 (259字节) ────────→ │ 收到头帧
  │                                    │ CRC校验✓
  │←──── ACK (6字节) ──────────────   │ 发送ACK
  │                                    │
  │───── DATA帧0 (259字节) ────────→  │ 收到数据帧0
  │                                    │ 保存Flash
  │←──── ACK (6字节) ──────────────   │ 发送ACK
  │                                    │
  │     ... (重复60次，帧1-60) ...    │
  │                                    │
  │───── END (4字节) ─────────────→   │ 收到END
  │                                    │ 发送COMPLETE
  │←──── COMPLETE (4字节) ───────    │
  │                                    │
```

### 重传流程（第3帧CRC失败）
```
上位机                                下位机
  │                                    │
  │───── DATA帧3 (259字节) ────────→  │ 收到帧3
  │                                    │ CRC校验✗
  │←──── NAK (6字节) ──────────────   │ 发送NAK
  │                                    │
  │（等待1秒）                         │
  │───── DATA帧3 (259字节) ────────→  │ 收到帧3（重传）
  │                                    │ CRC校验✓
  │←──── ACK (6字节) ──────────────   │ 发送ACK
  │                                    │
```

---

## 🛡️ 错误处理

| 错误场景 | 处理方案 |
|---------|--------|
| START_MARK错误 | 字节对齐，扔掉错误字节，等待下一个START_MARK |
| CHECKSUM错误 | 发送NAK，上位机重传 |
| CRC错误 | 发送NAK，上位机重传 |
| STOP_MARK错误 | 扔掉整帧，等待下一帧 |
| 超时 | 保持当前状态，等待重传 |
| 重传超过5次 | 中止传输，返回IDLE |

---

## 💡 设计优点

1. **清晰的帧结构** - START_MARK/STOP_MARK便于对齐和错误恢复
2. **独立帧验证** - 每帧都有CRC校验，不依赖全局状态
3. **低缓冲需求** - 只需一帧缓冲（259字节）
4. **可靠性高** - 主动ACK机制确保可靠传输
5. **易于扩展** - FRAME_TYPE可以扩展新类型
6. **故障恢复** - STOP_MARK便于从错误中快速恢复

---

## 🔄 与原协议对比

| 特性 | 原协议 | 新协议 |
|------|--------|--------|
| 帧大小 | 264字节 | 259字节 |
| 缓冲需求 | 264字节 | 259字节 |
| 帧头标记 | 0xA5A5A5A5 | 0x55 |
| 帧尾标记 | 0x5A5A5A5A | 0xAA |
| 错误恢复 | 困难 | 容易 |
| 状态机 | 复杂 | 清晰 |
| 校验方式 | CRC32 | CRC32 + CHECKSUM |
| 应答机制 | 无 | 主动ACK |

