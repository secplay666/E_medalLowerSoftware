================================================================================
                   图像传输时序分析与修复方案
================================================================================

【问题现象】
接收到的日志显示缓慢的逐字节接收，最终无法形成完整帧：

    [IMG_DBG] IDLE: Received 1 new bytes, total=1, rx_idx=1
    [IMG_DBG] IDLE: Received 1 new bytes, total=2, rx_idx=2
    [IMG_DBG] IDLE: Received 1 new bytes, total=3, rx_idx=3
    [IMG_DBG] IDLE: Received 1 new bytes, total=4, rx_idx=4
    [IMG_DBG] IDLE: Received 1 new bytes, total=5, rx_idx=5
    ...

【根本原因】Timer中断周期错误，导致处理频率远低于接收速率


================================================================================
                        参数计算
================================================================================

UART波特率: 115200 bps
每字节位数: 10 bits (1 start + 8 data + 1 stop)
单字节传输时间: 10 bits ÷ 115200 bps = 86.8 μs

图像帧大小: 264 字节
完整帧传输时间: 264 × 86.8 μs = 22,915 μs ≈ 23 ms

CPU配置:
  - PCLK 时钟: 8 MHz
  - Timer分频: /8 (BtPCLKDiv8)
  - 实际时钟: 1 MHz

【原配置】
  ARR值: 0xC537 = 50487
  中断周期: 50487 ÷ 1MHz = 50.487 ms

【新配置】
  ARR值: 0x03E7 = 999
  中断周期: 999 ÷ 1MHz = 0.999 ms ≈ 1 ms


================================================================================
                   修改前的时序问题分析
================================================================================

时刻(ms)    上位机发送                设备处理状态
────────────────────────────────────────────────────────────────
0ms         ┌─ A5 A5 A5 A5            [等待]
            │  (帧头，0.35ms完成)

0.35ms      │  元数据(8字节)           [等待]
            │  (0.7ms完成)

1.05ms      │  有效载荷(248字节)       [等待]
            │  开始传输...

22.9ms      └─ 5A 5A 5A 5A            [UART缓冲中已有264字节]
            (帧尾，0.35ms完成)
            整帧传输完成 ✓

50ms        (无动作)                   ★ 首次调用ImageTransfer_Process()
                                       此时rx_buf状态取决于队列处理速度
                                       但肯定不是第一次调用就得到完整帧!

【问题】第一次处理调用时，可能只有几个字节已从队列转移到rx_buf
        或者帧头还没有完全到达
        → 帧头识别失败，看到"5A 00 00 5A"这样的错误字节


================================================================================
                   修改后的时序方案
================================================================================

时刻(ms)    上位机发送                设备处理状态
────────────────────────────────────────────────────────────────
0ms         ┌─ A5 A5 A5 A5            [1ms调用 Process()] ✓ 处理4字节
            │
0.5ms       │                         [1ms调用 Process()] ✓ 处理更多数据

1.0ms       │  (继续发送元数据)         [1ms调用 Process()] ✓

1.5ms       │                         [1ms调用 Process()] ✓

2.0ms       │  (继续发送载荷)          [1ms调用 Process()] ✓

2.5ms       │                         [1ms调用 Process()] ✓

...         │  (持续发送248字节)        [持续每1ms处理一次] ✓✓✓

22.9ms      └─ 5A 5A 5A 5A            [1ms调用 Process()]
            整帧完成                    收到完整的264字节 ✓

【优势】
- 共有24次处理机会（22.9ms ÷ 1ms）
- 平均每次处理约1字节数据，足以追上接收流
- 帧头保证能完整接收并识别
- 缓冲区不会堆积，避免队列溢出


================================================================================
                    具体数据流对比
================================================================================

【修改前 - 缓冲区内容变化】

时刻0ms    接收UART中断: 字节0(0xA5)进入队列
时刻0.1ms  接收UART中断: 字节1(0xA5)进入队列
时刻0.2ms  接收UART中断: 字节2(0xA5)进入队列
...继续积累...
时刻22.9ms 接收UART中断: 字节263(0x5A)进入队列，264字节全部在UART队列

时刻50ms   ★ ImageTransfer_Process() 首次被调用
           从UART队列提取数据到rx_buf

           问题：如果队列处理速度慢，可能只提取了几个字节
           rx_buf 状态: [0xA5, 0xA5, 0x00, 0x5A, ...]
                         ↑    ↑     ↑    ↑
                    帧头的两个 中间某个错误字节 帧尾的某个

           调用 findFrameHeader() 去寻找 0xA5A5A5A5
           但收到的是 [0xA5, 0xA5, 0x00, 0x5A, ...] ← 找不到!

【修改后 - 缓冲区内容变化】

时刻0ms    接收UART中断: 字节0(0xA5)
时刻1ms    ★ ImageTransfer_Process() 调用1
           rx_buf已收到: [0xA5, 0xA5, 0xA5, 0xA5, ...] (继续)

时刻0.086ms 接收UART中断: 字节1(0xA5)
时刻0.172ms 接收UART中断: 字节2(0xA5)
时刻0.258ms 接收UART中断: 字节3(0xA5)
时刻0.344ms 接收UART中断: 字节4(0xXX)
时刻1.344ms ★ ImageTransfer_Process() 调用2
            rx_buf已收到: [0xA5, 0xA5, 0xA5, 0xA5, 0xXX, ...]
            现在 findFrameHeader() 成功找到 0xA5A5A5A5 ✓

时刻2ms    ★ ImageTransfer_Process() 调用3
时刻3ms    ★ ImageTransfer_Process() 调用4
...每1ms继续调用...

时刻22ms   ★ ImageTransfer_Process() 调用22
时刻22.9ms 所有264字节已完整到达rx_buf

时刻23ms   ★ ImageTransfer_Process() 调用23
           完整的264字节帧已在缓冲中
           帧头、元数据、载荷、帧尾全部完整 ✓
           成功识别并处理 ✓


================================================================================
                  关键结论
================================================================================

修改前 (50ms中断):
  ✗ ImageTransfer_Process() 被调用的太晚
  ✗ 数据到达(23ms) VS 首次处理(50ms) = 缺失27ms的处理机会
  ✗ 缓冲区管理状态不确定
  ✗ 帧头识别经常失败

修改后 (1ms中断):
  ✓ ImageTransfer_Process() 被频繁调用(24次/帧)
  ✓ 数据到达(23ms) VS 处理频率(1ms) = 充足的处理机会
  ✓ 缓冲区状态可控且可追踪
  ✓ 帧头识别成功率接近100%


================================================================================
                 修改清单
================================================================================

文件: source/main.c
位置: 第204-210行
操作: 将Timer中断周期从50.5ms改为1ms

  旧: Bt_ARRSet(TIM0, 0xC537);  // 50487, 周期≈50.5ms
  新: Bt_ARRSet(TIM0, 0x03E7);  // 999, 周期≈1ms

  旧: Bt_Cnt16Set(TIM0, 0xC537);
  新: Bt_Cnt16Set(TIM0, 0x03E7);


================================================================================
                  验证方法
================================================================================

方法1: 观察日志速度
  修改前: [IMG_DBG] IDLE 消息每50ms出现一次
  修改后: [IMG_DBG] IDLE 消息每1ms出现一次
          应该看到连续的日志输出

方法2: 检查帧接收成功
  发送一张图像后，应该看到:

  [IMG_DBG] Frame 1: Header pos=0, rx_idx=264
  [IMG_DBG] Frame complete: rx_idx=264 bytes
  [IMG_DBG] Parse: magic=0xA3, slot=0, frame=0
  [IMG_DBG] CRC: rx=0x12345678, calc=0x12345678
  [IMG_DBG] Frame 0 saved, frameIsFull=0x0000000000000001

  （而不是看到"RX_BUF in IDLE: 5A 00 00 5A"这样的错误）

方法3: 调用诊断函数
  在main.c中添加:
  ImageTransfer_PrintDiagnostics();

  检查输出是否显示:
  - Frames received > 0
  - Queue overflows = 0
  - UART RX count 接近 264


================================================================================
